[toc]

## Problem 3. 无重复字符的最长子串
> 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

### Keys: 
* **滑动窗口:**
逐步移动右指针，改变滑动窗口大小。不满足条件时移动左指针，改变滑动窗口位置。
以此遍历所有连续对象。

* **判断字符重复:**
  1. 哈希集合；
  1. 桶问题，每个字符分别对应0-255；

### Notes
* 循环过程中，判断条件和输出值的计算都应该在所有循环变量改变前或后。


## Problem 4. 寻找两个正序数组的中位数
> 给定两个大小为m和n的正序（从小到大）数组`nums1`和`nums2`。
请你找出并返回两个正序数组的中位数。
**进阶:** 你能设计一个时间复杂度为`O(log(m+n))`的算法解决此问题吗？

### Keys:
* **二分法:** 如果对时间复杂度的要求有log，通常都需要用到二分查找。

* **奇偶性的虚操作:** 
对任意序列`a1, a2, ..., an`，可以在每个数前后均虚拟加入`#`，
将数列长度由`n`增长为`2n+1`，恒为奇数。
在这种情况下，**每个位置可以通过 / 2 得到元素在原来序列中的位置**。


## Problem 5. 最长回文子串
> 给定字符串`s`，找到`s`中的最长回文子串。你可以假设`s`中的最大长度为1000。

### Keys:
* **动态规划:** 
  + 通过记录的子问题的解来得到原问题的解。
  + 状态转移方程。
  + 循环顺序。

**My solution:** 
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int maxlen = 0, begin = 0;  // 记录输出值
        int start=0, end=0;  // 回文子串中首尾元素的下标
        int n = s.size();
        int i = 0;   // 下标索引

        while(i < n) {
            start=i, end=i;
            while((i+1<n) && (s[i]==s[i+1])) {  // 找到连续相同字符
                ++end;
                ++i;
            }
            while((start-1>=0) && (end+1<n) && (s[start-1]==s[end+1])) {  // 中心发散
                --start;
                ++end;
            }
            if(end-start+1 > maxlen){  // 更新解
                maxlen = end-start+1;
                begin = start;
            }
            ++i;
        }
        return s.substr(begin, maxlen);
    }
};
```


