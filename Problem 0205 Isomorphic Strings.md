## § Problem 205 Isomorphic String
> 同构字符串。

如果 `s` 中的字符可以被替换得到 `t`，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但是字符可以映射自己本身。

**Q:** 给定两个字符串 `s` 和 `t`， 判断他们是否是同构的。


### Notes
* 依次比较两个数组相同位置上的字符，
如果都未在之前位置出现过，那么可以建立新的映射来满足同构关系；
如果该位置的字符在之前位置出现过，那么映射已经存在，
只有两个数组对应位置的映射相同时才满足同构关系。
那么我们只需要区分不同的映射，
并在遍历数组时记录每个位置上的映射，
通过比较对应位置的映射是否相同可以判断是否同构。
即同构问题转换为判断字符串中对应位置字符 **第一次出现的位置** 是否相同的问题。

* 同时遍历两个数组(已经假设数组长度相同)，
建立两个桶序列，用于判断字符是否重复出现，
如果发现新字符，就用当前字符的位置 `i+1` 表示对应的映射关系，
并把 `i+1` 置于对应的桶内 (使用 `i+1` 是为了区分第一个字符和未出现的字符)。
如果字符在之前位置出现过，那么检查对应的桶内的值是否相同，
是则返回 `true`, 否则返回 `false`。


**My Solution:** 
```cpp
class Solution {
public:
  bool isIsomorphic(std::string s, std::string t) {
    int n = s.size();
    std::vector<int> map_a(256,0), map_b(256,0);

    for (int i=0; i<n; ++i) {
      if (map_a[int(s[i])] != map_b[int(t[i])]) return false;
        map_a[int(s[i])] = i + 1;
        map_b[int(t[i])] = i + 1;
    }
    return true;
  }
};
```

